import { DatabaseManager } from './DatabaseManager'
import { AchievementModel } from './models/AchievementModel'

export class AchievementManager {
  private static instance: AchievementManager
  private databaseManager: DatabaseManager

  private constructor() {
    this.databaseManager = DatabaseManager.getInstance()
  }

  static getInstance(): AchievementManager {
    if (!AchievementManager.instance) {
      AchievementManager.instance = new AchievementManager()
    }
    return AchievementManager.instance
  }

  // åˆå§‹åŒ–é»˜è®¤æˆå°±åˆ°æ•°æ®åº“
  async initializeDefaultAchievements(): Promise<void> {
    try {
      const existingAchievements = await this.databaseManager.getAllAchievements()
      if (existingAchievements.length === 0) {
        const defaultAchievements = this.getDefaultAchievements()
        for (const achievement of defaultAchievements) {
          await this.databaseManager.addAchievement(achievement)
        }
        console.info('é»˜è®¤æˆå°±åˆå§‹åŒ–å®Œæˆ')
      }
    } catch (error) {
      console.error('åˆå§‹åŒ–é»˜è®¤æˆå°±å¤±è´¥:', error)
    }
  }

  // æ£€æŸ¥å¹¶æ›´æ–°æˆå°±è¿›åº¦
  async checkAndUpdateAchievements(): Promise<void> {
    try {
      const userStats = await this.databaseManager.getUserStats()
      const examRecords = await this.databaseManager.getExamRecords()
      const achievements = await this.databaseManager.getAllAchievements()

      for (const achievement of achievements) {
        if (achievement.isUnlocked) continue

        let shouldUpdate = false
        let newProgress = achievement.progress

        switch (achievement.id) {
          case 'first_question':
            if (userStats.totalQuestions > 0) {
              newProgress = 1
              shouldUpdate = true
            }
            break

          case 'answer_10':
            newProgress = Math.min(userStats.correctAnswers, 10)
            shouldUpdate = newProgress !== achievement.progress
            break

          case 'answer_50':
            newProgress = Math.min(userStats.correctAnswers, 50)
            shouldUpdate = newProgress !== achievement.progress
            break

          case 'answer_100':
            newProgress = Math.min(userStats.correctAnswers, 100)
            shouldUpdate = newProgress !== achievement.progress
            break

          case 'first_exam':
            if (examRecords.length > 0) {
              newProgress = 1
              shouldUpdate = true
            }
            break

          case 'exam_perfect':
            const perfectExams = examRecords.filter(exam => exam.score === 100)
            if (perfectExams.length > 0) {
              newProgress = 1
              shouldUpdate = true
            }
            break

          case 'exam_pass_5':
            const passedExams = examRecords.filter(exam => exam.passed)
            newProgress = Math.min(passedExams.length, 5)
            shouldUpdate = newProgress !== achievement.progress
            break

          case 'high_accuracy':
            if (userStats.accuracy >= 90 && userStats.totalQuestions >= 20) {
              newProgress = 1
              shouldUpdate = true
            }
            break
        }

        if (shouldUpdate) {
          achievement.updateProgress(newProgress)
          await this.databaseManager.updateAchievement(achievement)
          
          if (achievement.isUnlocked) {
            console.info(`æˆå°±è§£é”: ${achievement.title}`)
            // è¿™é‡Œå¯ä»¥æ·»åŠ æˆå°±è§£é”çš„é€šçŸ¥é€»è¾‘
          }
        }
      }
    } catch (error) {
      console.error('æ£€æŸ¥æˆå°±è¿›åº¦å¤±è´¥:', error)
    }
  }

  // è·å–é»˜è®¤æˆå°±åˆ—è¡¨
  private getDefaultAchievements(): AchievementModel[] {
    const achievements: AchievementModel[] = []

    // å­¦ä¹ æˆå°±
    achievements.push(new AchievementModel('first_question', 'åˆå­¦è€…', 'å®Œæˆç¬¬ä¸€é“é¢˜ç›®', 'ğŸ¯', 'å­¦ä¹ æˆå°±', 1, 'common'))
    achievements.push(new AchievementModel('answer_10', 'å°è¯•ç‰›åˆ€', 'ç´¯è®¡ç­”å¯¹10é“é¢˜ç›®', 'ğŸ“š', 'å­¦ä¹ æˆå°±', 10, 'common'))
    achievements.push(new AchievementModel('answer_50', 'å‹¤å­¦è‹¦ç»ƒ', 'ç´¯è®¡ç­”å¯¹50é“é¢˜ç›®', 'ğŸ†', 'å­¦ä¹ æˆå°±', 50, 'rare'))
    achievements.push(new AchievementModel('answer_100', 'å­¦éœ¸', 'ç´¯è®¡ç­”å¯¹100é“é¢˜ç›®', 'ğŸ‘‘', 'å­¦ä¹ æˆå°±', 100, 'epic'))

    // è€ƒæ ¸æˆå°±
    achievements.push(new AchievementModel('first_exam', 'è€ƒæ ¸æ–°æ‰‹', 'å®Œæˆç¬¬ä¸€æ¬¡è€ƒæ ¸', 'ğŸ“', 'è€ƒæ ¸æˆå°±', 1, 'common'))
    achievements.push(new AchievementModel('exam_perfect', 'å®Œç¾ç­”å·', 'åœ¨è€ƒæ ¸ä¸­è·å¾—æ»¡åˆ†', 'â­', 'è€ƒæ ¸æˆå°±', 1, 'epic'))
    achievements.push(new AchievementModel('exam_pass_5', 'è€ƒæ ¸è¾¾äºº', 'é€šè¿‡5æ¬¡è€ƒæ ¸', 'ğŸ–ï¸', 'è€ƒæ ¸æˆå°±', 5, 'rare'))

    // å‡†ç¡®ç‡æˆå°±
    achievements.push(new AchievementModel('high_accuracy', 'ç²¾å‡†å°„æ‰‹', 'ç­”é¢˜å‡†ç¡®ç‡è¾¾åˆ°90%ï¼ˆè‡³å°‘20é¢˜ï¼‰', 'ğŸ¯', 'å‡†ç¡®ç‡æˆå°±', 1, 'rare'))

    return achievements
  }

  // åœ¨ç­”é¢˜åè°ƒç”¨
  async onQuestionAnswered(isCorrect: boolean): Promise<void> {
    await this.checkAndUpdateAchievements()
  }

  // åœ¨è€ƒæ ¸å®Œæˆåè°ƒç”¨
  async onExamCompleted(score: number, passed: boolean): Promise<void> {
    await this.checkAndUpdateAchievements()
  }
}